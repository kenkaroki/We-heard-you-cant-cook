{"version":3,"file":"event-BOfuoqsS.js","sources":["../../../node_modules/@sveltejs/kit/src/runtime/server/constants.js","../../../node_modules/@sveltejs/kit/src/exports/internal/event.js"],"sourcesContent":["export const NULL_BODY_STATUS = [101, 103, 204, 205, 304];\n\n// eslint-disable-next-line n/prefer-global/process\nexport const IN_WEBCONTAINER = !!globalThis.process?.versions?.webcontainer;\n","/** @import { RequestEvent } from '@sveltejs/kit' */\n/** @import { RequestStore } from 'types' */\n/** @import { AsyncLocalStorage } from 'node:async_hooks' */\n\nimport { IN_WEBCONTAINER } from '../../runtime/server/constants.js';\n\n/** @type {RequestStore | null} */\nlet sync_store = null;\n\n/** @type {AsyncLocalStorage<RequestStore | null> | null} */\nlet als;\n\nimport('node:async_hooks')\n\t.then((hooks) => (als = new hooks.AsyncLocalStorage()))\n\t.catch(() => {\n\t\t// can't use AsyncLocalStorage, but can still call getRequestEvent synchronously.\n\t\t// this isn't behind `supports` because it's basically just StackBlitz (i.e.\n\t\t// in-browser usage) that doesn't support it AFAICT\n\t});\n\n/**\n * Returns the current `RequestEvent`. Can be used inside server hooks, server `load` functions, actions, and endpoints (and functions called by them).\n *\n * In environments without [`AsyncLocalStorage`](https://nodejs.org/api/async_context.html#class-asynclocalstorage), this must be called synchronously (i.e. not after an `await`).\n * @since 2.20.0\n *\n * @returns {RequestEvent}\n */\nexport function getRequestEvent() {\n\tconst event = try_get_request_store()?.event;\n\n\tif (!event) {\n\t\tlet message =\n\t\t\t'Can only read the current request event inside functions invoked during `handle`, such as server `load` functions, actions, endpoints, and other server hooks.';\n\n\t\tif (!als) {\n\t\t\tmessage +=\n\t\t\t\t' In environments without `AsyncLocalStorage`, the event must be read synchronously, not after an `await`.';\n\t\t}\n\n\t\tthrow new Error(message);\n\t}\n\n\treturn event;\n}\n\nexport function get_request_store() {\n\tconst result = try_get_request_store();\n\tif (!result) {\n\t\tlet message = 'Could not get the request store.';\n\n\t\tif (als) {\n\t\t\tmessage += ' This is an internal error.';\n\t\t} else {\n\t\t\tmessage +=\n\t\t\t\t' In environments without `AsyncLocalStorage`, the request store (used by e.g. remote functions) must be accessed synchronously, not after an `await`.' +\n\t\t\t\t' If it was accessed synchronously then this is an internal error.';\n\t\t}\n\n\t\tthrow new Error(message);\n\t}\n\treturn result;\n}\n\nexport function try_get_request_store() {\n\treturn sync_store ?? als?.getStore() ?? null;\n}\n\n/**\n * @template T\n * @param {RequestStore | null} store\n * @param {() => T} fn\n */\nexport function with_request_store(store, fn) {\n\ttry {\n\t\tsync_store = store;\n\t\treturn als ? als.run(store, fn) : fn();\n\t} finally {\n\t\t// Since AsyncLocalStorage is not working in webcontainers, we don't reset `sync_store`\n\t\t// and handle only one request at a time in `src/runtime/server/index.js`.\n\t\tif (!IN_WEBCONTAINER) {\n\t\t\tsync_store = null;\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"AAEA;AACO,MAAM,eAAe,GAAG,CAAC,CAAC,UAAU,CAAC,OAAO,EAAE,QAAQ,EAAE,YAAY;;ACH3E;AACA;AACA;;;AAIA;AACA,IAAI,UAAU,GAAG,IAAI;;AAErB;AACA,IAAI,GAAG;;AAEP,OAAO,kBAAkB;AACzB,EAAE,IAAI,CAAC,CAAC,KAAK,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,iBAAiB,EAAE,CAAC;AACvD,EAAE,KAAK,CAAC,MAAM;AACd;AACA;AACA;AACA,CAAC,CAAC,CAAC;;AAkDH;AACA;AACA;AACA;AACA;AACO,SAAS,kBAAkB,CAAC,KAAK,EAAE,EAAE,EAAE;AAC9C,CAAC,IAAI;AACL,EAAE,UAAU,GAAG,KAAK;AACpB,EAAE,OAAO,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE;AACxC,CAAC,CAAC,SAAS;AACX;AACA;AACA,EAAE,IAAI,CAAC,eAAe,EAAE;AACxB,GAAG,UAAU,GAAG,IAAI;AACpB,EAAE;AACF,CAAC;AACD;;;;","x_google_ignoreList":[0,1]}